# 트랜잭션 설계 보고서

## 1. 개요
본 보고서는 현재 개발 중인 콘서트 좌석 예약 시스템의 트랜잭션 설계와 서비스 분리 방안을 설명합니다. 특히 시스템의 기능들이 모놀리틱 구조에서 마이크로서비스 아키텍처로 확장될 때 발생하는 트랜잭션 처리의 한계와 이를 해결하기 위한 패턴과 설계를 다룹니다.

## 2. 기능별 트랜잭션 범위

현재 시스템에서 주요 트랜잭션 단위는 다음과 같습니다.

- **예약가능 콘서트 스케줄 조회**: 예약 가능한 콘서트 스케줄을 확인하는 기능.
```text
    예약가능 콘서트스케줄 조회 TX {
    예약가능_콘서트스케줄_조회()
}


```
- **예약가능 콘서트 스케줄 별 좌석 조회**: 선택한 스케줄의 예약 가능 좌석을 조회하는 기능.
```text
    예약가능 콘서트스케줄 별 좌석조회 TX {
    예약가능_콘서트스케줄_별_좌석조회()
}

```
- **포인트 충전**: 사용자의 포인트 정보를 조회하고 포인트를 충전하는 기능.
```text
    포인트충전 TX {
    유저포인트정보조회()
    포인트충전()
}

```
- **포인트 조회**: 사용자의 포인트 정보를 단순히 조회하는 기능.
```text
   포인트 조회 TX {
    유저포인트정보조회()
}
 

```
- **좌석 예약**: 특정 좌석의 상태를 변경하고 예약을 확정하는 기능.
```text
    좌석예약 TX {
    좌석상태변경()
    좌석예약()
}

```
- **결제**: 예약 내역 조회, 콘서트 정보 조회, 예약 확정, 결제 내역 생성, 유저 포인트 차감, 토큰 삭제와 같은 작업을 포함한 종합적인 결제 처리.
```text
    결제 TX {
    예약내역조회()
    콘서트정보조회()
    예약확정()
    결제내역생성()
    유저포인트차감()
    토큰삭제()
}


```

## 3. 서비스 분리의 필요성 - 결제

현재는 결제가 여러 도메인의 기능을 포함하고 있습니다. 그러나 서비스가 확장되어 예약, 콘서트, 포인트가 각각 독립된 서버에서 운영되면, 트랜잭션 범위가 넓은 `결제` 기능이 문제가 될 수 있습니다. 트랜잭션을 한 번에 완료할 수 없기 때문에 서비스 간의 데이터 일관성 유지와 트랜잭션의 원자성 보장이 어려워집니다.

특히 `토큰삭제`와 같이 결제 내역과 직접적인 관련이 적은 작업은 비동기적으로 분리하여 독립적으로 처리함으로써 서비스의 결합도와 성능을 개선할 수 있습니다.

## 4. 서비스 분리 후 예상되는 트랜잭션 처리의 한계

서비스 분리 후 다음과 같은 문제들이 예상됩니다.

### 4.1 트랜잭션 일관성 문제
모놀리틱 환경에서는 데이터베이스가 트랜잭션의 원자성, 일관성, 격리성, 지속성을 보장하지만, 마이크로서비스 아키텍처에서는 각 서비스가 개별 트랜잭션을 갖기 때문에 복합적인 트랜잭션에서 데이터 일관성 보장이 어렵습니다. 예를 들어 결제 과정에서 예약 서비스와 포인트 서비스가 동시에 참여할 경우, 하나의 트랜잭션에서 오류가 발생하면 각 서비스의 데이터를 일관되게 유지하는 것이 복잡해집니다.

### 4.2 오류 처리 및 롤백 문제
트랜잭션 중 하나의 서비스에서 오류가 발생할 경우 이미 수행된 작업을 롤백하기 어려워집니다. 예를 들어, 포인트 차감 후 예약 확정 과정에서 오류가 발생하면 이미 차감된 포인트를 복구하는 추가 작업이 필요합니다. 이는 각 서비스가 독립적이기 때문에 기존 트랜잭션처럼 자동으로 원자성을 유지하기 어렵습니다.

## 5. 트랜잭션 일관성 문제의 해결 방안: SAGA 패턴 적용

SAGA 패턴은 마이크로서비스 환경에서 데이터 일관성을 보장하기 위한 대표적인 설계 패턴입니다. 전체 비즈니스 트랜잭션을 각 서비스의 개별 로컬 트랜잭션으로 분리하고, 각 트랜잭션이 완료될 때마다 다음 트랜잭션을 트리거합니다. 주요 방식은 다음 두 가지로 나눌 수 있습니다.

### 5.1 코레오그래피 기반 SAGA
각 서비스가 트랜잭션이 완료되면 완료 이벤트를 발행하고, 다음 서비스를 트리거하는 방식입니다. 실패 시 보상 트랜잭션 이벤트를 발행하여 롤백을 시도합니다.

- **장점**: 서비스 간 결합도가 낮고, 하나의 서비스에 오류가 발생해도 나머지 시스템에 영향을 적게 미칩니다.
- **단점**: 트랜잭션 흐름이 복잡해지고, 서비스 간 종속성이 생길 수 있습니다.

### 5.2 오케스트레이션 기반 SAGA
중앙에서 SAGA Orchestrator가 각 서비스의 트랜잭션을 순차적으로 관리하며, 실패 시 보상 트랜잭션을 발생시켜 롤백을 시도합니다.

- **장점**: 트랜잭션 흐름이 명확하고, 서비스 간 결합도를 낮출 수 있습니다.
- **단점**: Orchestrator가 단일 장애 지점(SPOF)이 될 수 있으며, 확장성이 떨어질 수 있습니다.

### 5.3 예시: 결제 프로세스에 대한 SAGA 패턴 적용
결제 프로세스의 트랜잭션을 코레오그래피 기반 SAGA 패턴으로 분리할 수 있습니다. 예를 들어:
1. **예약 서비스**에서 예약을 확정하고 완료 이벤트를 발행합니다.
2. **포인트 서비스**는 예약 완료 이벤트를 구독하여 포인트를 차감하고, 완료 이벤트를 발행합니다.
3. **결제 서비스**는 포인트 차감 완료 이벤트를 구독하여 결제를 처리하고, 최종적으로 토큰 삭제와 메시지 전송 이벤트를 발행합니다.

이 과정을 통해 각 서비스가 독립적으로 동작하되, 이벤트를 통해 필요한 트랜잭션을 연속적으로 이어갈 수 있습니다.

```text
   여기 어딘가에 수도코드 고고고고  

```

## 6. 결론 및 기대 효과

현재 시스템에서 모놀리틱 환경의 단일 트랜잭션 범위는 유지보수성에 장점이 있지만, 서비스 확장이 필요한 경우 `토큰삭제`, `문자메시지 발송` 등의 기능을 비동기 프로세스로 분리하는 것이 필수적입니다. 이를 위해 SAGA 패턴을 도입하여 데이터 일관성을 관리하고, 서비스 결합도를 낮추어 마이크로서비스로의 전환을 지원합니다. 이 접근 방식은 장기적으로 서비스의 확장성과 유지보수성을 높이고, 비즈니스 요구사항에 유연하게 대응할 수 있는 시스템을 구축하는 데 기여할 것입니다.
