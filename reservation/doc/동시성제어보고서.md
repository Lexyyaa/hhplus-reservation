#  동시성이슈 및 제어 보고서
콘서트 좌석예약 서비스에서 발생할 수 있는 동시성 이슈와 이를 해결하기 위한 과정에 대한 보고서

### 동시성 이슈 상황

#### 1) 좌석예약
- 기능설명 : 사용자가 선택한 좌석에 대해 선점한다.
- 문제상황 :
    - 여러 사용자가 동일한 좌석에 대해 예약요청을 하는경우에 요청들이 순차적으로 독립되게 처리되지 않는다면 예약정보가 덮어씌여지는 분실 갱신이 발생할 수 있다.
- 목표상황 :
    - 여러 사용자가 하나의 좌석에 대해 예약 요청을 했을때 가장 먼저 요청한 사용자에게 좌석이 할당된다.
    - 다른 사용자들에게는 "이미 예약된 좌석입니다." 라는 메시지가 전달되어야 한다.
  
#### 2) 포인트 충전
- 기능설명 : 사용자가 충전요청한 금액에 대해 정상적으로 충전된다.
- 문제상황 :
    - 사용자가 동시에 여러번의 충전요청을 했을 때 실제 요청한 금액과 충전된 금액이 일치하지 않는 문제가 발생한다.
- 목표상황 :
    - 포인트조회 시 요청한 포인트만큼 순서대로 충전된다.

#### 3) 결제
- 기능설명 : 사용자가 예약한 좌석에 대해 결제한다.
- 문제상황 :
  - 사용자가 동시에 여러번의 결제요청을 했을 때 예약한 정보에 대한 금액만큼 정상적으로 포인트가 차감되지 않을 수 있다.
- 목표상황 :
    - 사용자가 요청한 예약에 대해 정상적으로 포인트가 차감되며 이후 결제요청은 실행하지 않는다.

### 문제 해결과정 

##### 1) 좌석예약
- 동시성 테스트를 위한 시나리오
> 1000명의 유저가 동시에 하나의 좌석에 대해 예약요청을 했을 경우 한명만 성공하고 모두 실패한다.

```java
    @SpringBootTest
    class ReservationConcurrencyTest {
    
        private static final Logger log = LoggerFactory.getLogger(ReservationConcurrencyTest.class);
    
        @Autowired
        private ReservationUsecase reservationUsecase;
    
        private static final int NUMBER_OF_USERS = 1000;
    
        private ExecutorService executorService = Executors.newFixedThreadPool(NUMBER_OF_USERS);
        private CountDownLatch latch = new CountDownLatch(NUMBER_OF_USERS);
    
        @Test
        @DisplayName("동시 예약 시도 - 1000명 중 한 명만 성공")
        void 동시_예약_시도_1000명_한명만_성공() throws InterruptedException {
            Long concertScheduleId = 1L;
            Long seatId = 5L;
    
            List<Callable<Boolean>> tasks = IntStream.rangeClosed(1, NUMBER_OF_USERS)
                    .mapToObj(userId -> (Callable<Boolean>) () -> attemptReservation((long) userId, concertScheduleId, seatId))
                    .toList();
    
            List<Future<Boolean>> results = executorService.invokeAll(tasks);
    
            long successCount = 0;
            long failureCount = 0;
    
            for (Future<Boolean> result : results) {
                try {
                    if (result.get()) {
                        successCount++;
                    } else {
                        failureCount++;
                    }
                } catch (InterruptedException | ExecutionException e) {
                    Thread.currentThread().interrupt();
                    log.error("결과 가져오기 실패: {}", e.getMessage());
                }
            }
    
            assertThat(successCount).isEqualTo(1); 
            assertThat(failureCount).isEqualTo(NUMBER_OF_USERS - 1); 
        }
    
        Boolean attemptReservation(Long userId, Long concertScheduleId, Long seatId) {
            try {
                latch.countDown(); 
                latch.await(); 
    
                reservationUsecase.reserve(
                        concertScheduleId,
                        new ReserveSeatRequest(userId, List.of(seatId))
                );
                log.info("예약 성공: userId={}, concertScheduleId={} , seatIds={}", userId ,concertScheduleId ,List.of(seatId));
                return true;
            } catch (BizException e) {
                log.warn("예약 실패: userId={}, 원인={}", userId, e.getErrorType().getMessage());
                return false;
            } catch (Exception e) {
                Thread.currentThread().interrupt();
                log.error("스레드 인터럽트 발생: userId={}", userId);
                return false;
            }
        }
    }
```

- 낙관적 락 적용 및 실행결과

<img src="https://github.com/user-attachments/assets/0fdc356c-4265-4a0e-af81-222b77311781" width="50%" height="40%">

- 비관적 락 적용 및 실행결과

<img src="https://github.com/user-attachments/assets/9c2d6f5b-1cc6-41c4-85cb-b764b88458f9" width="50%" height="50%">


##### 2) 포인트 충전 
- 동시성 테스트를 위한 시나리오
> 한명의 유저가 동시에 충전요청을 보냈을 때 요청한 만큼의 포인트가 정상적으로 충전된다.
```java
    @SpringBootTest
    class UserPointConcurrencyTest {
    
        private static final Logger log = LoggerFactory.getLogger(ReservationConcurrencyTest.class);
    
        @Autowired
        private UserPointUsecase userPointUsecase;
    
        @Autowired
        private JPAUserPointRepository jpaUserPointRepository;
    
        @Test
        @DisplayName("동시 포인트 충전 시도 - 요청한 순서대로 ")
        void 동시_포인트_충전_순서대로_성공() throws InterruptedException {
            Long userId = 1L;
            Long amount = 500L;
    
            UserPoint currUserPoint = jpaUserPointRepository.findById(1L).orElse(null);
            Long beforePoint = currUserPoint.getPoint();
    
            int attemptCount = 30;
            ExecutorService executorService = Executors.newFixedThreadPool(attemptCount);
            CountDownLatch latch = new CountDownLatch(attemptCount);
    
            AtomicInteger successCount = new AtomicInteger(0);
            AtomicInteger failureCount = new AtomicInteger(0);
    
            for (int i = 0; i < attemptCount; i++) {
                executorService.submit(() -> {
                    try {
                        userPointUsecase.chargePoint(userId, amount);
                        successCount.incrementAndGet();
                    } catch (Exception e) {
                        failureCount.incrementAndGet();
                    } finally {
                        latch.countDown();
                    }
                });
            }
            latch.await();
            executorService.shutdown();
    
            log.info("successCount: {}", successCount.get());
            log.info("failCount: {}", failureCount.get());
    
            UserPoint userPoint = jpaUserPointRepository.findById(1L).orElse(null);
    
            assertThat(userPoint.getPoint())
                    .isEqualTo(beforePoint+ (amount * attemptCount));
        }
    }
```

- 비관적 락 적용 및 실행결과

<img src="https://github.com/user-attachments/assets/696a19cd-8b29-423d-ac2c-7d14b58829cc" width="50%" height="50%">

- 낙관적 락 적용 및 실행결과

<img src="https://github.com/user-attachments/assets/e9c9deca-d4bc-4a2b-8ad3-3fe57b49c8d0" width="50%" height="50%">
<img src="https://github.com/user-attachments/assets/808e82f6-072f-4732-b704-492ffd7316d3" width="50%" height="50%">

##### 3) 결제
- 동시성 테스트를 위한 시나리오
> 한명의 유저가 예약한 하나의 좌석에 대해 결제요청을 500번을 진행했을 때 한번의 결제요청만 성공한다.

```java
    @SpringBootTest
    class PaymentConcurrencyTest {
    
        @Autowired
        private PaymentUsecase paymentUsecase;
    
        @Autowired
        private UserPointRepository  userPointRepository;
    
        @Test
        @DisplayName("동시 결제 시도 - 예약 건 만큼만 포인트 차감")
        void 동시_결제_시도_정상적인_포인트_차감() throws InterruptedException {
            String token = "valid_token";
            Long reservationId = 1L;
            Long totalPrice = 40000L;
            Long userId = 1L;
            Long point = 40000L;
    
            int attemptCount = 500;
            ExecutorService executorService = Executors.newFixedThreadPool(attemptCount);
            CountDownLatch latch = new CountDownLatch(attemptCount);
    
            AtomicInteger successCount = new AtomicInteger(0);
            AtomicInteger failCount = new AtomicInteger(0);
    
            for (int i = 0; i < attemptCount; i++) {
                executorService.submit(() -> {
                    try {
                        paymentUsecase.pay(token, reservationId, userId);
                        successCount.incrementAndGet();
                    } catch (Exception e) {
                        failCount.incrementAndGet();
                    } finally {
                        latch.countDown();
                    }
                });
            }
            latch.await();
            executorService.shutdown();
    
            UserPoint userPoint = userPointRepository.findByUserId(userId);
    
            assertThat(userPoint.getPoint()).isEqualTo(point-totalPrice);
    
            assertThat(successCount.get()).isEqualTo(1);
    
            assertThat(failCount.get()).isEqualTo(attemptCount - 1);
        }
    }
```

- 비관적 락(예약정보조회), 비관적 락(포인트정보조회) 적용 및 실행결과

<img src="https://github.com/user-attachments/assets/e40d842f-4b67-40b2-84cb-ca57f271f5de" width="50%" height="50%">

- 낙관적 락(예약정보조회), 비관적 락(포인트정보조회) 적용 및 실행결과

<img src="https://github.com/user-attachments/assets/5a109903-6dde-476a-b72b-0ceeab67ad36" width="50%" height="50%">



###### 참고자료
- https://hyperconnect.github.io/2019/11/15/redis-distributed-lock-1.html
- https://helloworld.kurly.com/blog/distributed-redisson-lock/#2-redis%EC%9D%98-redisson-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%84%A0%EC%A0%95-%EC%9D%B4%EC%9C%A0
