### **콘서트 좌석 예약 서비스 API 분석 및 성능 이슈 보고서**

#### 1. **부하 테스트 대상 선정**
- **대상**:
   - 주요 API (예: 좌석 예약, 공연 정보 조회, 결제 처리)
   - 병목 가능성이 높은 Redis 기반 대기열 처리 및 캐싱 로직

#### 2. **배포 스펙 검토**
- **결과 분석**:
   - 메모리 및 CPU 병목 파악
   - RPS를 기준으로 최소 배포 스펙 도출


#### **2. 예상 병목 지점 및 선정 이유**

| **지점**                                 | **선정 이유**                                                                                                     |
|------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| **Redis**                                | - 대기열 토큰 발급 및 polling 조회 시 높은 동시 요청 발생<br>- Redis의 네트워크 I/O 및 설정(LRU 정책, Max Memory) 병목 |
| **데이터베이스**                         | - 스케줄 및 좌석 데이터의 복잡한 필터링 쿼리 처리<br>- 다중 트랜잭션 처리로 인한 Lock 충돌 가능성                     |
| **좌석 예약 API (POST /{concertScheduleId}/seat/{userId})** | - 높은 동시성 요청 시 트랜잭션 병목 발생 가능<br>- 좌석 상태 업데이트에 대한 Lock 문제                                |
| **결제 API (POST /{reservationId}/{userId})** | - 외부 API 호출(결제 및 알림) 지연 발생 가능<br>- 좌석 및 스케줄 상태 업데이트 시 동시성 처리 문제                     |

---

#### **부하 테스트 진행 이유**

1. **시스템 성능 확인**
   - 애플리케이션이 다양한 동시 사용자 요청을 처리하는 데 있어 병목 구간을 식별하고 성능을 최적화하기 위해 테스트를 진행합니다.

2. **배포 스펙 최적화**
   - Docker 컨테이너의 CPU 및 메모리 설정에 따른 성능 변화를 분석하여 효율적인 리소스 사용 및 배포 환경을 설계합니다.

3. **신뢰성 확보**
   - 실제 운영 환경에서 발생할 수 있는 부하를 시뮬레이션하여 시스템 안정성을 검증하고 장애 대응 능력을 향상합니다.

---

#### **테스트 진행 도구**

1. **K6**
   - REST API 및 비동기 로직에 대한 성능 테스트를 위해 K6를 사용합니다.
   - 테스트 결과를 InfluxDB에 저장하고 Grafana로 시각화합니다.

2. **Grafana**
   - InfluxDB에 저장된 데이터를 기반으로 성능 지표(p50, p90, p99, 처리량 등)를 시각화하여 분석합니다.

---

#### **테스트 진행 환경**

1. **Docker 실행 환경**
   - Docker Compose를 사용하여 모든 서비스를 컨테이너로 배포
   - Docker Engine: 최신 버전 (v20.10 이상 권장)
   - 실행 옵션:
      - CPU: `0.5 core`, `1 core`, `2 cores`
      - Memory: `512MB`, `1GB`, `2GB`

2. **Java 환경**
   - JDK: OpenJDK 17
   - Spring Boot: 3.1.x (Docker 프로파일 활성화)

3. **MySQL**
   - **버전**: 8.0.33
   - **환경**:
      - 데이터베이스: `app_db`
      - 연결 유저: `app_user`
      - Docker 포트 매핑: `3307:3306`
   - **성능 관련 설정**:
      - `innodb_buffer_pool_size`: 512MB
      - `max_connections`: 100

4. **Redis**
   - **버전**: Latest (Docker 기반)
   - **환경**:
      - 캐시 및 대기열 처리용으로 사용
      - Docker 포트 매핑: `6379:6379`
   - **설정**:
      - 메모리 제한 없음 (테스트 용도)
      - Eviction Policy: `allkeys-lru`

5. **Kafka**
   - **버전**: Confluent Kafka 7.4.0
   - **구성**:
      - Zookeeper 연결: `zookeeper:2181`
      - 내부/외부 리스너:
         - INTERNAL: `kafka:9092`
         - EXTERNAL: `localhost:29092`
   - **포트 매핑**: `9092:9092`, `29092:29092`

6. **InfluxDB**
   - **버전**: 1.8.5
   - **데이터베이스**: `myk6db`
   - **포트 매핑**: `8086:8086`

7. **Grafana**
   - **버전**: 최신 (Docker 기반)
   - **포트 매핑**: `3000:3000`
   - **데이터 소스**: InfluxDB


### **1. 대량 토큰발급요청 테스트 (`token-load-test.js`)**
##### 선정이유 
- load_test: Redis의 동시 요청 처리 성능 확인.
- endurance_test: 지속적인 토큰 발급 요청 처리 안정성 확인.
- stress_test: Redis 한계 및 병목 탐지.
- peak_test: 단기간에 대량 요청 처리 가능 여부 확인.
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
   scenarios: {
      load_test: {
         executor: 'ramping-vus',
         startVUs: 0,
         stages: [
            { duration: '30s', target: 100 }, 
            { duration: '30s', target: 200 }, 
            { duration: '30s', target: 300 }, 
            { duration: '30s', target: 0 },   
         ],
      },
      endurance_test: {
         executor: 'constant-vus',
         vus: 300, 
         duration: '2m', 
      },
      stress_test: {
         executor: 'ramping-vus',
         startVUs: 0,
         stages: [
            { duration: '30s', target: 100 }, 
            { duration: '30s', target: 250 }, 
            { duration: '30s', target: 300 }, 
            { duration: '30s', target: 0 },   
         ],
      },
      peak_test: {
         executor: 'constant-vus',
         vus: 500, 
         duration: '1m', 
      },
   },
   thresholds: {
      http_req_duration: ['p(99)<1000'], 
      http_req_failed: ['rate<0.01'],   
      http_req_body_size: ['p(95)<1000'], 
      http_reqs: ['count>100'], 
   },
   summaryTrendStats: ['avg', 'p(90)', 'p(95)', 'p(99)', 'max'],
};

export default function () {
   const userId = Math.floor(Math.random() * 10000) + 1;
   const res = http.post(`http://localhost:28080/api/queue/token/${userId}`);
   check(res, { 'status is 200': (r) => r.status === 200 });
   sleep(1);
}

```

---

### **2. 콘서트조회,예약,결제 테스트 (`user_ticket_payment.js`)**
##### 선정이유
콘서트 스케줄조회 ->  콘서트 좌석조회 -> 좌석 예약 -> 결제 프로세스를 모두 지나가는 경우에 대한 부하테스트
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
    scenarios: {
        load_test: {
            executor: 'ramping-vus',
            startVUs: 0,
            stages: [
                { duration: '1m', target: 100 },
                { duration: '3m', target: 500 },
                { duration: '1m', target: 0 },
            ],
        },
        endurance_test: {
            executor: 'constant-vus',
            vus: 300,
            duration: '30m',
        },
        stress_test: {
            executor: 'ramping-vus',
            startVUs: 0,
            stages: [
                { duration: '2m', target: 100 },
                { duration: '2m', target: 1000 },
                { duration: '1m', target: 2000 },
                { duration: '1m', target: 0 },
            ],
        },
        peak_test: {
            executor: 'constant-vus',
            vus: 1000,
            duration: '5m',
        },
    },
    thresholds: {
        http_req_duration: ['p(95)<500'],
        http_req_failed: ['rate<0.01'],
    },
};

const BASE_URL = 'http://localhost:28080';
const TEST_USER_IDS = [1, 2, 3, 4, 5];

export default function () {
    const userId = TEST_USER_IDS[Math.floor(Math.random() * TEST_USER_IDS.length)];

    const res = http.get(`${BASE_URL}/check/${userId}`);

    check(res, {
        'status is 200': (r) => r.status === 200,
        'response contains balance': (r) => JSON.parse(r.body).hasOwnProperty('balance'),
    });

    sleep(1);
}
```

---

### **3. 인기 좌석 예약 (`popular_seat_access.js`)**
##### 선정이유
인기 좌석에 대하여 동시에 많은 사용자가 몰릴 경우에 대한 부하테스트 

```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
   scenarios: {
      load_test: {
         executor: 'ramping-vus',
         startVUs: 0,
         stages: [
            { duration: '1s', target: 1 },
            { duration: '2s', target: 5 },
            { duration: '1s', target: 0 },
         ],
      },
      endurance_test: {
         executor: 'constant-vus',
         vus: 10,
         duration: '4s',
      },
      stress_test: {
         executor: 'ramping-vus',
         startVUs: 0,
         stages: [
            { duration: '2s', target: 5 },
            { duration: '2s', target: 20 },
            { duration: '2s', target: 0 },
         ],
      },
      peak_test: {
         executor: 'constant-vus',
         vus: 10,
         duration: '2s',
      },
   },
   thresholds: {
      http_req_duration: ['p(99)<1000'], // 99% 요청이 1초 이하
      http_req_failed: ['rate<0.01'],   // 실패율 1% 미만
      http_req_body_size: ['p(95)<1000'], // 요청 크기 95%가 1KB 이하
      http_reqs: ['count>100'], // 최소 100개 이상의 요청 처리
   },
   summaryTrendStats: ['avg', 'p(90)', 'p(95)', 'p(99)', 'max'],
};

export default function () {
   const userId = Math.floor(Math.random() * 10000) + 1;
   const scheduleId = 2;
   const seats = [Math.floor(Math.random() * 5) + 1]; // 좌석 ID 배열 생성

   // 요청 바디
   const payload = JSON.stringify({
      userId: userId, // 사용자 ID
      seats: seats    // 좌석 배열
   });

   // 요청 헤더 설정
   const params = {
      headers: {
         'Content-Type': 'application/json', // JSON 형식 지정
      },
   };

   const res = http.post(`http://localhost:28080/api/reserve/${scheduleId}/seat/${userId}`, payload, params);
   check(res, { 'status is 200': (r) => r.status === 200 });
   sleep(1);
}
```

## K6 결과 추추가!!!! 

### 장애 대응 보고서: K6 부하 테스트 실행 중 발생한 장애 분석 및 대응 방안


#### **1. 장애 원인 **

1. **서버 자원 부족**:
   - HikariCP 커넥션 풀이 부족하거나 부하 테스트로 인해 자원이 고갈됨.
2. **DB 병목 현상**:
   - 느린 쿼리 또는 연결 반환 지연으로 인해 요청이 타임아웃.
3**테스트 부하 과다**:
   - 서버 용량을 초과한 부하로 인해 응답 시간이 증가.

---

#### **4. 개선 방안 요약**
1. **서버 및 DB 최적화**:
   - HikariCP 커넥션 풀 크기 증가.
   - 쿼리 최적화 및 캐싱 도입.

3. **서버 자원 증설**:
   - 필요한 경우 서버의 CPU, 메모리, 네트워크 자원을 증설.

4. **모니터링 도입**:
   - Spring Boot Actuator 및 DB 모니터링을 통해 병목 원인 지속 분석.

---
